{"name":"TinyJ","tagline":"TinyJ is not yet-another Java-framework, it's collection of java libraries sharing not interfaces and classes but concepts. The main objective is to provide independently usable artifacts covering many of your daily java needs.","body":"\r\n## Goals\r\n\r\n### Choice of weapons\r\n\r\nIt should up to you to decide which parts of TinyJ you want to use.\r\n\r\n\r\n### Express yourself\r\n\r\nTinyJ aims to help you to express your self easily yet concisely in java code.\r\n\r\n\r\n### Connect\r\n\r\nIntegrating TinyJ into you code and connecting it to third party libraries\r\nshould be easy and non intrusive.\r\n\r\n\r\n### Being understood\r\n\r\nTinyJ aims to keep it's own codebase readable and comprehensible.\r\n\r\n\r\n### Small footprint\r\n\r\nAs the name suggests, each TinyJ project aims to keep it's footprint small.\r\nThis encompasses artifact size, memory and cpu usage. Obviously there will be\r\ntrade-offs. As for artifact size this means well below 1Mbyte.\r\n\r\n\r\n\r\n## Concepts\r\n\r\n### KISS\r\n\r\n#### simple scope\r\nEach TinyJ project covers a very specific use case giving you the choice of\r\nwhat to take and what to leave. This also helps to keep the TinyJ codebase the\r\nmodular and comprehensible.\r\n\r\n#### simple usage (aka no magic)\r\nTinyJ tries not to be smart about what you want. Instead it tries to give you\r\nthe means necessary to express your self easily yet concisely.\r\n\r\n#### simply readable\r\nTinyJ code should be readable and easily navigable.\r\n\r\n\r\n### Integrable but not integrated\r\n\r\nIntegration should happen as much high level as possible, again leaving as\r\nmuch room for choice as possible. To make that feasible TinyJ tries hard to\r\nmake integration as seamless and painless as possible and to keep third party\r\nlibraries out.\r\n\r\n\r\n\r\n## Principles\r\n\r\n### soLid\r\n\r\nThe [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))\r\nprinciples shall apply to all of TinyJ's codebase with a strong emphasize on\r\nLiskov's substitution principle. It's awesome. Really, it is.\r\n\r\n\r\n### Use standard components\r\n\r\nJava's JRE is rich with abstractions and interfaces readily available in\r\n(almost) every java based project. TinyJ builds on top of that wherever it\r\ncan. This keeps integrating TinyJ simple and seamless.\r\n\r\nAnd if the JRE is not enough there are even more in the  `javax` namespace.\r\n\r\n\r\n### Lambda integration\r\n\r\nJava 8 lambdas are just giving us a neat syntax for defining inline functions,\r\nthey give us also a very useful tool to integrate things based on concepts\r\ninstead of interfaces by adapting functional interfaces on the fly.\r\n\r\nAn example:\r\n```java\r\ninterface TinyJApi {\r\n  @FunctionalInterface interface IntAccepter {\r\n    void acceptThatInt(int i);\r\n  }\r\n  void aFunction(IntAccepter in);\r\n}\r\n\r\ninterface ThatOtherApi {\r\n  @FunctionalInterface interface IntTaker {\r\n    void takeThatInt(int i);\r\n  }\r\n  IntTaker thatOtherFunction();\r\n}\r\n\r\nclass MyCode {\r\n  TinyJApi tinyJApi;\r\n  ThatOtherApi thatOtherApi;\r\n\r\n  void bringingThingsTogether() {\r\n    tinyJApi.aFunction(\r\n      thatOtherApi.thatOtherFunction()::takeThatInt);\r\n  }\r\n}\r\n```\r\n\r\nIt doesn't get easier than this and obviously it just works the other way\r\naround. And by the way, the `@FunctionalInterface` annotation in purely\r\noptional here and with code completion you don't even have to remember that\r\n```takeThatInt``` bit.\r\n\r\nTinyJ enables this integration pattern by using\r\nfunctional interfaces whenever it's sensible.\r\n\r\n\r\n### Clean code\r\n\r\nTinyJ's codebase tries to follow the rules from\r\n[\"Clean Code\"](https://books.google.com/books/about/Clean_Code.html?id=dwSfGQAACAAJ \"Clean Code @ books.google.com\")\r\nas faithful as possible.\r\n\r\n\r\n### Tested\r\n\r\nEverything released from TinyJ passed a carefully created test suite.\r\nBugfixes should include new tests, linked to the github issue, proving that\r\nthe Bug is gone.\r\n\r\n\r\n### Semantic Versioning\r\n\r\nBeing committed to standard components and keeping things simple TinyJ needs\r\nto break things from time to time (like whenever there is a hot new Java\r\nversion) in order provide new features and improve on those upstream changes.\r\n[Semantic Versioning](http://semver.org) is used to communicate such changes.\r\n\r\nThere will be bugfix releases for previous major versions as time permits.\r\nWithin a TinyJ project different major releases are treated as independent\r\ncodebases sharing a common goal and mindset.\r\n\r\n\r\n### Shade\r\n\r\nSometimes there is the really nagging desire to use some small third party\r\nlibrary (like TinyJ :) ). By shading these dependencies TinyJ keeps you\r\nblissfully unaware of such internal details.\r\n\r\n\r\n\r\n## Things to come\r\n\r\n### tinyj-web-mvc (~32Kbytes)\r\n\r\nTinyJ will start soon (before end of March 2016) with yet another Web MVC\r\nimplementation. It's in polishing now so stay tuned.\r\n\r\n\r\n### tinyj-test-servlet (~16Kbytes)\r\n\r\nMock implementation for HttpServletRequest and HttpServletResponse. A preview\r\nwill accompany the tinyj-web-mvc release as it's used in the testsuite.\r\n\r\n\r\n### tinyj-web-server (in planning)\r\n\r\nFinding that tinyj-test-servlet HttpServletRequest an HttpServletResponse\r\nimplementations give you almost everything needed to implement the HTTProtocol\r\nlet's lift that into a minimal viable HTTP server implementation (may\r\noptionally be accompanied with tinyj-web-mvc).\r\n\r\n\r\n### tinyj-di (in planning)\r\n\r\nInspired by [TinyDI](https://github.com/jonaash/tinydi) tinyj-di aims to be\r\nyet another [JSR 330](https://jcp.org/en/jsr/detail?id=330) implementation.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}